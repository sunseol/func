import { cookies } from 'next/headers';
import { createClient } from '@/lib/supabase/server';
import { 
  DocumentResponse,
  AIpmErrorType,
  ProjectRole
} from '@/types/ai-pm';

// POST /api/ai-pm/documents/[documentId]/approve - Approve a document
export async function POST(
  request: NextRequest,
  { params }: { params: { documentId: string } }
) {
  try {
    const cookieStore = cookies();
    const supabase = await createClient();
    
    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: AIpmErrorType.UNAUTHORIZED, message: '인증이 필요합니다.' },
        { status: 401 }
      );
    }

    const { documentId } = params;

    // Get document with project info
    const { data: document, error: queryError } = await supabase
      .from('planning_documents')
      .select(`
        *,
        project:projects(id, name)
      `)
      .eq('id', documentId)
      .single();

    if (queryError || !document) {
      return NextResponse.json(
        { error: AIpmErrorType.DOCUMENT_NOT_FOUND, message: '문서를 찾을 수 없습니다.' },
        { status: 404 }
      );
    }

    // Check if document is in pending_approval status
    if (document.status !== 'pending_approval') {
      return NextResponse.json(
        { 
          error: AIpmErrorType.VALIDATION_ERROR, 
          message: '승인 대기 중인 문서만 승인할 수 있습니다.' 
        },
        { status: 400 }
      );
    }

    

    // Update document status to official
    const { data: updatedDocument, error: updateError } = await supabase
      .from('planning_documents')
      .update({
        status: 'official',
        approved_by: user.id,
        approved_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .eq('id', documentId)
      .select(`*`)
      .single();

    if (updateError) {
      console.error('Error approving document:', updateError);
      return NextResponse.json(
        { error: AIpmErrorType.DATABASE_ERROR, message: '문서 승인 중 오류가 발생했습니다.' },
        { status: 500 }
      );
    }

    // Manually fetch user details
    const userIds = [updatedDocument.created_by, updatedDocument.approved_by].filter(Boolean);
    const { data: profiles, error: profilesError } = await supabase
      .from('user_profiles')
      .select('id, full_name')
      .in('id', userIds);

    const { data: users, error: usersError } = await supabase
      .from('users')
      .select('id, email')
      .in('id', userIds);

    if (profilesError || usersError) {
      console.error('Error fetching user details for approved document:', profilesError || usersError);
      // Not critical, continue with response
    }
    
    const userMap = new Map();
    if (profiles) {
      profiles.forEach(p => userMap.set(p.id, { ...userMap.get(p.id), full_name: p.full_name }));
    }
    if (users) {
      users.forEach(u => userMap.set(u.id, { ...userMap.get(u.id), email: u.email }));
    }

    // Create approval history record
    await createApprovalHistory(supabase, {
      documentId,
      userId: user.id,
      action: 'approved',
      previousStatus: 'pending_approval',
      newStatus: 'official'
    });

    // Format response
    const documentWithUsers = {
      ...updatedDocument,
      creator_email: userMap.get(updatedDocument.created_by)?.email || '',
      creator_name: userMap.get(updatedDocument.created_by)?.full_name || null,
      approver_email: userMap.get(updatedDocument.approved_by)?.email || null,
      approver_name: userMap.get(updatedDocument.approved_by)?.full_name || null
    };

    const response: DocumentResponse = { document: documentWithUsers };
    return NextResponse.json(response);

  } catch (error) {
    console.error('Approve Document API Error:', error);
    return NextResponse.json(
      { 
        error: AIpmErrorType.INTERNAL_ERROR, 
        message: '서버 오류가 발생했습니다.',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined
      },
      { status: 500 }
    );
  }
}

// POST /api/ai-pm/documents/[documentId]/reject - Reject a document
export async function PUT(
  request: NextRequest,
  { params }: { params: { documentId: string } }
) {
  try {
    const cookieStore = cookies();
    const supabase = await createClient();
    
    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: AIpmErrorType.UNAUTHORIZED, message: '인증이 필요합니다.' },
        { status: 401 }
      );
    }

    const { documentId } = params;
    const body = await request.json();
    const { reason } = body;

    // Get document with project info
    const { data: document, error: queryError } = await supabase
      .from('planning_documents')
      .select(`
        *,
        project:projects(id, name)
      `)
      .eq('id', documentId)
      .single();

    if (queryError || !document) {
      return NextResponse.json(
        { error: AIpmErrorType.DOCUMENT_NOT_FOUND, message: '문서를 찾을 수 없습니다.' },
        { status: 404 }
      );
    }

    // Check if document is in pending_approval status
    if (document.status !== 'pending_approval') {
      return NextResponse.json(
        { 
          error: AIpmErrorType.VALIDATION_ERROR, 
          message: '승인 대기 중인 문서만 반려할 수 있습니다.' 
        },
        { status: 400 }
      );
    }

    

    // Update document status back to private
    const { data: updatedDocument, error: updateError } = await supabase
      .from('planning_documents')
      .update({
        status: 'private',
        approved_by: null,
        approved_at: null,
        updated_at: new Date().toISOString()
      })
      .eq('id', documentId)
      .select(`*`)
      .single();

    if (updateError) {
      console.error('Error rejecting document:', updateError);
      return NextResponse.json(
        { error: AIpmErrorType.DATABASE_ERROR, message: '문서 반려 중 오류가 발생했습니다.' },
        { status: 500 }
      );
    }
    
    // Manually fetch user details
    const userIds = [updatedDocument.created_by].filter(Boolean);
    const { data: profiles, error: profilesError } = await supabase
      .from('user_profiles')
      .select('id, full_name')
      .in('id', userIds);

    const { data: users, error: usersError } = await supabase
      .from('users')
      .select('id, email')
      .in('id', userIds);

    if (profilesError || usersError) {
      console.error('Error fetching user details for rejected document:', profilesError || usersError);
      // Not critical, continue with response
    }
    
    const userMap = new Map();
    if (profiles) {
      profiles.forEach(p => userMap.set(p.id, { ...userMap.get(p.id), full_name: p.full_name }));
    }
    if (users) {
      users.forEach(u => userMap.set(u.id, { ...userMap.get(u.id), email: u.email }));
    }

    // Create approval history record
    await createApprovalHistory(supabase, {
      documentId,
      userId: user.id,
      action: 'rejected',
      previousStatus: 'pending_approval',
      newStatus: 'private',
      reason
    });

    // Format response
    const documentWithUsers = {
      ...updatedDocument,
      creator_email: userMap.get(updatedDocument.created_by)?.email || '',
      creator_name: userMap.get(updatedDocument.created_by)?.full_name || null,
      approver_email: null,
      approver_name: null
    };

    const response: DocumentResponse = { document: documentWithUsers };
    return NextResponse.json(response);

  } catch (error) {
    console.error('Reject Document API Error:', error);
    return NextResponse.json(
      { 
        error: AIpmErrorType.INTERNAL_ERROR, 
        message: '서버 오류가 발생했습니다.',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined
      },
      { status: 500 }
    );
  }
}



// Helper function to create approval history record
async function createApprovalHistory(
  supabase: any,
  data: {
    documentId: string;
    userId: string;
    action: 'approved' | 'rejected' | 'requested';
    previousStatus: string;
    newStatus: string;
    reason?: string;
  }
) {
  await supabase
    .from('document_approval_history')
    .insert([{
      document_id: data.documentId,
      user_id: data.userId,
      action: data.action,
      previous_status: data.previousStatus,
      new_status: data.newStatus,
      reason: data.reason,
      created_at: new Date().toISOString()
    }]);
}