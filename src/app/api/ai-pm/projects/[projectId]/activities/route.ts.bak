import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { AIpmErrorType } from '@/types/ai-pm';

type Params = {
  projectId: string;
};

// ... (interface definitions remain the same)

export async function GET(
  request: NextRequest,
  { params }: { params: Params }
) {
  try {
    const supabase = await createClient();
    const projectId = params.projectId;
    
    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const includeStats = url.searchParams.get('includeStats') === 'true';
    const includeMemberSummary = url.searchParams.get('includeMemberSummary') === 'true';

    // Check project access
    const { data: projectMember, error: memberError } = await supabase
      .from('project_members')
      .select('id, role')
      .eq('project_id', projectId)
      .eq('user_id', user.id)
      .single();

    if (memberError && memberError.code !== 'PGRST116') {
        const { data: userProfile } = await supabase.from('user_profiles').select('role').eq('id', user.id).single();
        if (userProfile?.role !== 'admin') {
            return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
        }
    }

    // Mock data for now
    const mockActivities = [
      {
        id: '1', project_id: projectId, user_id: user.id, activity_type: 'project_created',
        target_type: 'project', target_id: projectId, metadata: { project_name: '테스트 프로젝트' },
        description: '프로젝트를 생성했습니다', created_at: new Date().toISOString(),
        user_name: '사용자', user_email: user.email
      }
    ];

    const response: any = {
      activities: mockActivities,
      pagination: { limit, offset: 0, hasMore: false }
    };

    if (includeStats) {
      response.collaborationStats = {
        total_documents: 0, official_documents: 0, pending_documents: 0,
        total_members: 1, total_activities: 1, last_activity_at: new Date().toISOString()
      };
    }

    if (includeMemberSummary) {
      response.memberSummary = [
        {
          user_id: user.id, user_name: '사용자', user_email: user.email || 'Unknown',
          role: 'owner', documents_created: 0, documents_updated: 0, documents_approved: 0,
          ai_conversations: 0, last_activity_at: new Date().toISOString()
        }
      ];
    }

    return NextResponse.json(response);

  } catch (error) {
    console.error('Error in project activities API:', error);
    return NextResponse.json({ error: 'Internal server error', details: (error as Error).message }, { status: 500 });
  }
}

export async function POST(
  request: NextRequest,
  { params }: { params: { projectId: string } }
) {
  try {
    const supabase = await createClient();
    const projectId = params.projectId;
    
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { activity_type, target_type, target_id, metadata = {}, description } = body;

    if (!activity_type || !description) {
      return NextResponse.json({ error: 'Activity type and description are required' }, { status: 400 });
    }

    const { data: result, error } = await supabase.rpc('log_project_activity', {
      p_project_id: projectId, p_user_id: user.id, p_activity_type: activity_type,
      p_target_type: target_type, p_target_id: target_id, p_metadata: metadata,
      p_description: description
    });

    if (error) {
      console.error('Error logging activity:', error);
      return NextResponse.json({ error: 'Failed to log activity' }, { status: 500 });
    }

    return NextResponse.json({ success: true, activity_id: result });

  } catch (error) {
    console.error('Error in log activity API:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
